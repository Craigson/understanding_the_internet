
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Understanding the Internet</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">



    <!-- Custom styles for this template -->
    <link href="css/style.css" rel="stylesheet">

    <!-- //  -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a id="title" class="navbar-brand" href="#">100 days of 'Understanding The Internet...'</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <form class="navbar-form navbar-right">
            <input type="text" class="form-control" placeholder="Search..." id="searchbar" autocomplete="off" >
          </form>
        </div>
      </div>

    </nav>



    <div class="container-fluid">

        <div id="search_results">hello</div>

        <div id="content" class="col-sm-8  col-md-8 col-md-offset-2 col-lg-8 col-lg-offset-2 main">

          <h1 class="page-header">Foreword</h1>

          <p class ="lead">
            This site is inspired by the '100 days of making' class at NYU's ITP grad progam. It serves as documentation and a point of reference for my own attempt at further understanding how the internet works.  Every day, for one hundred days, I'll be identifying an idea, term or topic that I've encountered along the way, researching it, and doing my best to explain it in (mostly) my own words.  Wikipedia serves as primary source, unless otherwise stated. My hope is that in the process of bolstering my own understanding, and creating a glossary of sorts, it might be of use to someone else in the future.
          </p>

          <hr>


              <div id="glossary-container">

              <!-- TEMPLATE -->
                <!--
                <div id="____" class="col-md-12 entry">
                  <h5 class="day">____</h5>

                  <h3>____</h3>

                  <h4 class="definition">""</h4>
                    <b>Overview:</b><br>


                  <div class="descripion">

                  </div>

                </div>

                  -->


              <!-- HTTP -->

                <div id="http" class="col-md-12 entry">
                  <h5 class="day">_0</h5>
                  <h3>HTTP</h3>
                  <h4 class="definition">"Hypertext Transfer Protocol"</h4>

                      <div class="description">
                        <b>Overview:</b><br>
                        <p>
                          HTTP was initiated by Tim Berners-Lee at CERN in 1989.
                          HTTP is a request-response application-level protocol based on the client-server model.
                          HTTP is a TCP/IP based communication protocol that's used to deliver data (HMTL files, images, query results etc.) between computers in a standardized way.  Basically, it's responsible for transporting most of the data across the world wide web.
                          The connection defaults to TCP port 80.
                          HTTP is both connectionless and stateless. This means that once an HTTP request is made, the client disconnects from the server and waits for a response.
                          When the server responds, it re-establishes the connection in order to send the response. The fact that HTTP is stateless refers to the fact that
                          the client are only aware of each other during the current request. Once it's over, they forget about each other.
                          Any kind of data can be sent by HTTP, provided the client and server both know how to handle the data. Both client and
                          server are required to specify the content's MIME-type.
                          An HTTP request does exactly what it sounds like, as in it is requesting information/data from a specific server.
                        </p>

                       <p>
                          <b>Request/Response Structure:</b><br>
                          Every HTTP request/response has the same structure:
                          <ul>
                            <li>A startline</li>
                            <li>Zero or more header fields followed by CRLF (carriage return and line feed characters)</li>
                            <li>An empty line (indicated end of header fields)</li>
                            <li>Optional message-body</li>
                          </ul>
                        </p>

                        <b>HTTP headers:</b><br>
                        <p>
                          Each request/response contains a number of important HTTP Protocol Parameters (which are located in the headers).  Header fields provide the necessary information about the request/response, or about the data in the message body. Header fields include information such as:
                          <ul>
                            <li>HTTP Version,</li>
                            <li>Uniform Resource Identifiers (URIs are used to identify a resource and establish a connection),</li>
                            <li>Date/Time formats,</li>
                            <li>Character sets (eg. US-Ascii),</li>
                            <li>Content Encodings (this value indicates which encoding algorithm has been used to encode the content),</li>
                            <li>Media Types (for data typing and type negotiation),</li>
                            <li>Language Tags</li>
                          </ul>
                        </p>

                        <p>
                          <b>Start-Line:</b><br>
                          The start-line can either be a request-line, or status-line, depending on whether it was sent from the client or the server.
                          Both contains the HTTP version ( eg. HTTP/1.1), whereas the request-line will contain the request type (eg. GET) and the endpoint (eg. /example.html).
                          The Status line contains a status code (eg. 200) and a status message (eg. OK).
                          <ul>
                          <li>Example Request-Line: <b>GET /example.com HTTP/1.1</b></li>
                          <li>Example Status-Line: <b>HTTP/1.1 200 OK</b></li>
                          </ul>
                        </p>

                        <p>
                          <b>Message Body:</b><br>
                          The message body is optional, but if it is present it carries the entity-body of the request/response.
                          The Content-Type and Content-Length properties in the header describe the content.
                          The message body contains the actual data. In the case of a client request, this could be form data, a file that's been uploaded etc.
                          In the case of the server's response, it could contain a file, an image etc., but is more often that not an HTML page.
                        </p>

                        <p>
                          <b>Request Methods:</b><br>
                          The request method indicates the action to be performed on the resource identified
                          by the given Request-URI.  The methods are as follows:
                          <ul>
                          <li><b>GET:</b> retrieves information from the server using the URI as a query string</li>
                          <li><b>HEAD:</b> same as GET, but transfers the status line and the header only</li>
                          <li><b>POST:</b> used to send data to server, eg. form data and files (more secure than GET)</li>
                          <li><b>PUT:</b> replaces target resource with uploaded content</li>
                          <li><b>DELETE:</b> removes target resource given by URI</li>
                          <li><b>CONNECT:</b> establisheds a tunnel to the server identified by URI</li>
                          <li><b>OPTIONS:</b> describe the communication options for the target resource, it can be used by the client to find out the HTTP methods and other options that the web server supports.</li>
                          <li><b>TRACE:</b> Performs a message loop back test along with the path to the target resource ( mainly used for debugging during development)</li>
                          </ul>
                        </p>

                        <p>
                          <b>HTTP Status Codes and Messages:</b><br>
                          Status codes are 3-digit integers that form part of the server response, indicating the success-state of the request.  The first digit describes the class of the response.
                          <ul>
                          <li><b>1xx:</b> Informational</li>
                          <li><b>2xx:</b> Success</li>
                          <li><b>3xx:</b> Redirection</li>
                          <li><b>4xx:</b> Client Error</li>
                          <li><b>5xx:</b> Server Error</li>
                          </ul>
                        </p>

                        <p>
                          <b>Caching:</b><br>
                          Performance across HTTP can be improved through the use of caching.  Caching helps eliminate the need to send requests, in certain cases, as well as the need for the server to send full responses (ie. using the back button in the browser and reloading a page that you've previously visited.  Certain information is cached so that it doesn't need to be requested from the server again).  Caching can be control using the Cache-Control header
                        </p>

                        <p>
                          <b>An important note on security:</b><br>
                          HTTP clients come into contact with a lot of personalized/private data (eg. names, locations, email addresses, passwords, encryption keys etc.). HTTP is an unsecured, unecrypted protocol, and much of this information can be 'leaked'.  For this reason, it's important to use HTTPS wherever possibly.  Not only is it encrypted, but it's also been designed to be faster!
                        </p>
                    </div>

                </div><!--  end of http -->


                <!-- TCP -->

                <div id="tcp" class="col-md-12 entry">
                  <h5 class="day">_1</h5>

                  <h3>TCP</h3>

                  <h4 class="definition">"Transmission Control Protocol"</h4>

                  <div class="descripion">
                      <b>Overview:</b><br>

                      <p>
                          TCP is one of the main protocols belonging to the Internet Protocol Suite.  It has its origins in the early network implementation in which it was complimented by the Internet Protocol ( IP ). For this reason, the entire suite is often referred to as TCP/IP.  TCP forms part of the Transport Layer of the Internet Protocol Suite.  The Transport Layer lives below the Application Layer (containing protocols like HTTP, DHCP, DNS, FTP, SSH etc.) and above the Internet Layer.
                      </p>

                      <img id="ips_img" src="images/ips.png" class="img-responsive center-block">
                      <span style="text-align: center; display: block; margin-bottom: 20px"> Internet Protocol Suite (wikipedia) </span>


                      <p>
                          TCP provides more reliable, ordered and error-checked delivery of a stream of octets (bytes) between applications running on hosts communicating over an IP network.  Internet applications such as the World Wide Web, e-mail, remote access, SSH, and file transfer are all dependent on TCP.  TCP prioritizes reliability, as opposed to UDP which prioritizes reduced latency.
                          TCP is a standardized protocol which means individual applications don't have to have knowledge of the mechanisms used for sending data via a link - for example how the data is split into packets. TCP handles all the particulars relating to handshaking and transmission and offers the application an abstraction of the connection.
                      </p>

                      <p>
                          TCP is a reliable stream delivery service which guarantees that all bytes received will be identical with bytes sent and in the correct order. Since packet transfer by many networks is not reliable, a technique known as 'positive acknowledgement with re-transmission' is used to guarantee reliability. This fundamental technique requires the receiver to respond with an acknowledgement message as it receives the data. The sender keeps a record of each packet it sends and maintains a timer from when the packet was sent. The sender re-transmits a packet if the timer expires before receiving the message acknowledgement. The timer is needed in case a packet gets lost or corrupted.
                      </p>

                      <p>
                          <b>An important distinction to note is that IP handles the delivery of data, while TCP keeps track of the 'segments', or packets, that the data is divided into. For example, when an HTML file is sent from a web server, the TCP software layer of that server divides the sequence of file octets (bytes) into segments and forwards them individually to the IP software layer (Internet Layer). The Internet Layer encapsulates each TCP segment into an IP packet by adding a header that includes (among other data) the destination IP address. When the client program on the destination computer receives them, the TCP layer (Transport Layer) re-assembles the individual segments and ensures they are correctly ordered and error-free as it streams them to an application.</b>
                      </p>

                      <p>
                          TCP accepts data from a datastream (ie. from an application), separates it into chunks, and adds a TCP header, thus creating a TCP segment.  This segment is then encapsulated into an IP datagram.  This encapsulated entity is often referred to as a 'data packet'.  A TCP segment has a header and a data section.  The data section carries the payload, while the header holds important information about the segment in at least 10 mandatory fields. This include:
                          <ul>
                              <li>Source port (16bits)</li>
                              <li>Destination port (16bits)</li>
                              <li>Sequence Number (32 bits)</li>
                              <li>Acknowledgement number (32 bits)</li>
                              <li>Data offset (4 bits)</li>
                              <li>Reserverd (3 bits)</li>
                              <li>Flags, aka Control bits (9 bits)</li>
                              <li>Window Size (16 bits)</li>
                              <li>Checksum (16 bits)</li>
                              <li>Urgent Pointer (16 bits)</li>
                              <li>Options ( 0 - 320bits, in 32 bit incremenets )</li>
                              <li>Padding</li>
                          </ul>

                      </p>

                      <p>
                          The TCP window prevents a fast sender from overwhelming a slow
                          consumer application.
                      </p>

                      <p>
                            More to come...
                      </p>




                  </div>

                </div> <!--  end of TCP -->

                <!-- IP -->

                <div id="ip" class="col-md-12 entry">

                      <h5 class="day">_2</h5>

                      <h3>IP</h3>

                      <h4 class="definition">"Internet Protocol"</h4>

                      <div class="descripion">

                        <b>Overview:</b><br>
                          <p>
                            The IP protocol standardizes the way computers (hosts), either over the internet or any other IP network, forward or route packages based on their IP addresses.  In other words, its main responsibility is to relay datagrams across network boundaries.  Delivery from the source host to the destination host ( thus communication is host-to-host ) is possible because both IP addresses are present in the packet headers.  The protocol also defines the packet structure that encapsulates data passed down from the layers above ( eg. TCP or UDP from the Transport Layer ).  Every datagram has a header and payload, where the payload contains data passed down from a layer above (eg. a TCP segment from the Transport Layer). This method of nesting the data payload in a packet with a header is called encapsulation.
                         </p>

                         <img id="dgram_img" src="images/dgram.png" class="img-responsive center-block">

                         <span style="text-align: center; display: block; margin-bottom: 20px"> UDP datagram (wikipedia) </span>

                          <p>
                            IPv4 ( Internet Protocol Version 4 ) is the dominant protocol on the internet, with the adoption of its successor IPv6 ( Internet Protocol Version 6 ) taking place slowly.  The slow adoption is due to a number of reason, primarily the cost of replacing the millions of devices that use IPv4 and their lack of compatibility with the new protocol.
                          </p>

                          <p>
                            <b>Addressing and Routing:</b><br>
                            Every host has an assosciated IP address. The address space is divided into network and subnetworks and is used to designate specific networks or routing prefixes.  All hosts perform routing, however routers are responsible for transporting packets across network boundaries. Routers communicate with one another via routing protocols. IP routing also happens in local networks. Ethernet switches use MAC addresses to perform actual routing, but also make use of protocols such as IP multicasting.
                          </p>



                      </div>

                </div> <!-- end of IP -->

                <!-- ENCAPSULATION -->

                <div id="encapsulation" class="col-md-12 entry">

                  <h5 class="day">_3</h5>

                  <h3>encapsulation</h3>

                  <h4 class="definition">"encapsulation"</h4>

                  <div class="descripion">
                      <b>Networking:</b><br>
                      <p>
                        In a networking context, the method of nesting the data payload in a packet with a header is known as 'encapsulation'.
                      </p>

                      <p>
                          <b>Programming:</b>
                          In a programming context, 'encapsulation' is a feature of OOP ( object-oriented programming ) and is a mechanism whereby access to an object's components are restricted from outside access.  It can also be considered a method of combining methods/functions along with data inside a datastructure known as a 'class'.
                      </p>

                  </div>

                </div> <!-- end of encapsulation -->

                <!-- OCTET -->

                <div id="octet" class="col-md-12 entry">
                  <h5 class="day">_4</h5>

                  <h3>octet</h3>

                  <h4 class="definition">"Octet"</h4>
                    <p>
                        An 'octet' and a 'byte' are essentially the same thing ( 8 bits of data ).
                        However, the term 'octet' is used exclusively within the context of networks.</p>

                </div>  <!-- end of octet -->

                <!-- UDP -->

                <div id="udp" class="col-md-12 entry">
                  <h5 class="day">_5</h5>

                  <h3>UDP</h3>

                  <h4 class="definition">"User Datagram Protocol"</h4>

                  <div class="descripion">
                    <b>Overview:</b><br>
                        <p>
                            UDP is a core member of the Internet Protocol Suite and resides in the Transport Layer. Data is transferred as datagrams to other hosts on an IP network.  UDP is a simple connectionless transmission model that makes use of checksums for validating data integrity, and port numbers for addressing different functions at the source and destination of the datagram.  Unlike TCP, UDP has no handshaking mechanism and as such, the reliability of delivery is determined by the underlying network.  Therefore, there's no guarentee of delivery, ordering or duplicate protection.  Any error checking that takes place needs to be performed in the application layer.  In applications where speed is prefferable over reliability, like streaming, where dropped packets are not the end of the world, UDP is the preferred protocol.
                        </p>

                        <p>
                            Because it is transaction-oriented protocol, it's suitable for simple query-response protocols such as DNS ( Domain Name System ) and NTP ( Network Time Protocol ).  Datagrams allowing for modeling other protocols involved in things like IP tunneling or RPC ( Remote Procedure Call ) and NFS ( Network File System ).  Because the protocol is simple, it assists in accomplishing tasks without a full protocol stack, such as in the case of DHCP.  The fact that it's stateless makes it suitable for a large number of clients, like when streaming media, and the lack of retransmission delays makes it suitable for realtime applications like VoIP and online games. In addition, because communication is unidirectional, it's suitable for broadcasting.
                        </p>

                        <b>Packet Structure</b><br>
                        <p>
                        The UDP header consists of four fields, each of which is 2 bytes.  The fields are as follows:
                        <ul>
                        <li> <b>Source Port Number ( optional ):</b> Identifies the sender's port.</li>
                        <li> <b>Destination Port Number:</b> Identifies the receivers's port.</li>
                        <li><b>Length:</b> Specifes the length, in bytes, of the UDP header and payload data.  The minimum length is 8 bytes (ie. just the header ).  There is a theoretical limit of 65,535 bytes ( 8 byte header and 65,527 bytes of data ) in a UDP datagram. In reality it's slightly less due to the IP header size.
                        </li>
                        <li><b>Checksum ( optional ):</b> The checksum field is used for error-checking of the header and data.  It carries all zeros if unused.</li>
                        </ul>
                        </p>

                        <p>
                            <b>Applications:</b><br>
                            UDP applications are designed with packet loss, duplication and ordering erros in mind.  Several vital internet applications make use of UDP such as DNS, SNMP, RIP, DHCP. Voice and video traffic is usually transferred using UDP because a slight loss in quality is preferred over delays due to packet-loss.
                        </p>

                        <p>
                            <b>Features:</b><br>
                            <ul>
                                <li><b>Unidirectional:</b> It's an end-to-end connectionless protocol that transmits information in one direction, refardless of the receiver's state. </li>
                                <li><b>Unreliable:</b> No concept of delivery acknowledgment, retransmission or timeout.</li>
                                <li><b>Unordered:</b> Order of packet
                                receipt can't be predicted. </li>
                                <li><b>Lightweight:</b> No tracking of connections or ordering of messages means it's a small transport layer build on top of IP.</li>
                                <li><b>Datagrams:</b> Packets are sent individually and only checked for errors upon receipt by the application layer. Packets have defined boundaries, meaning the read operation at the receiver socket yields the message as it was originally sent.</li>
                                <li><b>No congenstion control:</b> The protocol has no implementation for contorlling congestion. </li>
                                <li><b>Broadcasting:</b> Because it is connectionless, UDP can broadcast, ie. packets can be addressed to be receivable by all devices on the subnet. </li>

                            </ul>


                  </div>

                </div> <!-- end of UDP -->

                <!-- DATAGRAM -->

                <div id="datagram" class="col-md-12 entry">
                  <h5 class="day">_6</h5>
                  <h3>datagram</h3>
                  <h4 class="definition">"datagram"</h4>
                  <div class="descripion">
                        <p>
                          <b>Overview:</b><br>
                          The specification defines a datagram as <i>“A self-contained, independent entity of data carrying sufficient information to be routed from the source to the destination computer without reliance on earlier exchanges between this source and destination computer and the transporting network.”</i>
                      </p>

                      <p>
                          In essence, a datagram is a basic transfer unit assosciated with a packet-switched network.
                          'Datagrams' and 'packets' are ostensibly the same, however a datagram is generally a packet from an unreliable service
                          which cannot notify the sender if it fails.  The term 'packet' can apply to any packet, reliable or not.
                          Protocols like UDP have IP packets that can be described as datagrams. All IP packets are datagrams. However, a TCP segment can refer to an
                          IP fragmentation of a datagram, which are then referred to as 'packets'.
                      </p>

                      <p>
                          <b>Structure:</b><br>
                          Every datagram has two components: the header and data payload.  The header contains information required for routing
                          the datagram across an IP network.  Headers will include things such as source and destination addresses,
                          whereas the payload contains the data being transported.  The process of nesting payloads with headers is called encapsulation.
                      </p>

                  </div>

                </div>

        </div> <!-- end of glossary container -->

        <!-- BACK BUTTON -->
      <div id="back_button" class="overlay center-block">BACK</div>

      </div> <!-- end of content -->

    </div> <!-- end of fluid container -->


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="js/jquery.min.js"/>
    // <script>window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')</script>
    <script src="js/bootstrap.min.js"></script>

    <!-- // <script src="js/glossary.js"></script> -->
    <script src="js/script.js"></script>

  </body>
</html>
